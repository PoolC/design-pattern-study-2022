
### 객체지향 만으로는 모든 것을 해결하긴 어렵다.
- 

### Strategy Pattern :
- 알고리즘군을 정의하고 각각을 _캡슐화_ 하여 교환해서 사용할 수 있도록 만든다.
  - 기존에는 `duck` 클래스의 동작을 __동작의 모음__ 이라고 간주했지만, 이를 __알고리즘의 집합__ 으로 간주하는 것.
- 이를 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.
#### IS-A 관계
- 'A는 B이다' 일때의 '이다'와 같다.
  - 추상화들 사이의 포함 관계를 의미하여, 한 클래스 A가 다른 클래스 B의 서브클래스 (파생 클래스)임을 의미함.
  - 다시 말하자면, 타입 A는 타입 B의 Specification을 암시하므로 서브타입이라고 할 수 있음.
#### HAS-A 관계
- 구성 관계를 의미하며 한 오브젝트 (구성된 객체, 또는 부분 및 멤버 객체)가 다른 오브젝트에 '속한다 (Belongs to)'를 말함.
- 간단하게 말해서, has-a 관계는 멤버 필드라고 불리는 객체를 의미함.
- 참고: [상속 (Inheritance vs Composition)](https://iyoungman.github.io/designpattern/Inheritance-and-Composition/)
